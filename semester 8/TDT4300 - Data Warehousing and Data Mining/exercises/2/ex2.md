# TDT4300 â€” Assignment 2
# ASSOCIATION ANALYSIS

relevant lectures:
6(assosiation rules),7

## 1 Apriori Algorithm


## 2 FP-Growth Algorithm
<!-- find all frequent itemsets with minimum support -->

Transactions in a transaction database:
| TID | Items         |
|-----|---------------|
| T1  | b, e, g       |
| T2  | b, d, i       |
| T3  | b, d, e, f    |
| T4  | a, d, e       |
| T5  | d, e          |
| T6  | b, d, j       |
| T7  | b, c, d, e, f |
| T8  | b, d, e, f    |
| T9  | b, e, h       |

Frequencies:
| Item | Frequency |
|------|-----------|
| a    | 1         |
| b    | 7         |
| c    | 1         |
| d    | 5         |
| e    | 6         |
| f    | 3         |
| g    | 1         |
| h    | 1         |
Frequency of each item.


Frequent patter set:
<!-- L = {b:7,e:6,d:5,f:3} -->
<!-- Includes the item and the frequency for each item within the minimum support count, meaning a frequency of at least 3 in this case. -->
Minsup = 9*0.22=>1

Ordered item set:
| TID | Items         | Ordered item set |
|-----|---------------|------------------|
| T1  | b, e, g       | b, e             |
| T2  | b, d, i       | b, d             |
| T3  | b, d, e, f    | b, e, d, f       |
| T4  | a, d, e       | e, d             |
| T5  | d, e          | e, d             |
| T6  | b, d, j       | b, d             |
| T7  | b, c, d, e, f | b, e, d, f       |
| T8  | b, d, e, f    | b, e, d, f       |
| T9  | b, e, h       | b, e             |
Items ordered descending where only items that exist in L are included.

Trie:
![](images/2022-02-11-11-47-40.png)
Each ordered item set is added to the trie by increasing the count of the item node if it has been walked before, and creating a new branch where the path does not exist by initializing an item node with count = 1.

Conditional pattern base:
| Item | Conditional pattern base |
|------|--------------------------|
| b    |                          |
| e    | {b:5}, {e:2}             |
| d    | {b,e:3}, {b:2}, {e:2}    |
| f    | {b,e,d:3}                |
Each path to each item along with the frequency of the item by following the given path. Starting and ending node is not included in the pattern base.

Conditional frequent pattern tree:
| Item | Conditional pattern base | Conditional frequent pattern tree |
|------|--------------------------|-----------------------------------|
| b    |                          |                                   |
| e    | {b:5}, {e:2}             |                                   |
| d    | {b,e:3}, {b:2}, {e:2}    |                                   |
| f    | {b,e,d:3}                | {b,e,d:3}                         |
Describes the pattern that is common to all conditional pattern bases, allong with the total frequency count.

Frequent pattern rules:
| Item | Frequent pattern generated |
|------|----------------------------|
| b    |                            |
| e    |                            |
| d    |                            |
| f    | <b,f:3>, <e,f:3>, <d,f:3>  |
These are generated by pairing the conditional frequent pattern tree with each item along with the corresponding frequency count.





## 3 KNIME


## 4 Compact Representation of Frequent Itemsets
| Closed Frequent Itemsets | Support Count |
|--------------------------|---------------|
| {b}                      | 10            |
| {d}                      | 13            |
| {a, d}                   | 11            |
| {b, d}                   | 7             |
| {b, e}                   | 8             |
| {d, e}                   | 6             |
| {a, b, e}                | 7             |
| {a, c, d}                | 6             |
| {b, d, e}                | 4             |
| {a, c, d, e}             | 5             |

The closed frequent itemsets are candidates for all frequent itemsets.

Want to generate all frequent itemsets including the support counts.


k_max = 4 // the maximum size of the closed frequent itemsets ({a, c, d, e})

find all frequent itemsets of size k_max (4) down to 1 by iterating k:

k=4:
{a,c,d,e} = 5 // already know this
// support for the rest will be {a,b,c,d,e}.support (since there is only one superset) = {a,c,d,e}.support + {b}.support = 5 + 10 = 15
{b,a,c,d} = 15
{b,c,d,e} = 15
{b,a,d,e} = 15
{b,a,c,e} = 15

k=3:
{a,d,e} = 4 // already know this
{a,b,e} = 7 // already know this
{a,c,d} = 6 // already know this
{a,b,c} = max({b,a,c,d},{b,a,c,e}) = max(15,15) = 15
{a,b,d} = max({b,a,c,d},{b,a,d,e}) = max(15,15) = 15
{a,c,e} = max({a,c,d,e},{b,a,c,e}) = max(5,15) = 15
{b,c,d} = max({b,a,c,d},{b,c,d,e}) = max(15,15) = 15
{b,c,e} = max({b,c,d,e}, {b,a,c,e}) = max(15,15) = 15
{b,d,e} = max({b,c,d,e},{b,a,d,e}) = max(15,15) = 15
{c,d,e} = max({a,c,d,e},{b,c,d,e}) = max(5,15) = 15

k=2:
{a,d} = 11 // already know this
{b,d} = 7 // already know this
{b,e} = 8 // already know this
{a,b} = max({a,b,e},{a,b,c},{a,b,d}) = max(7,15,15) = 15
{a,c} = max({a,c,d},{a,b,c},{a,c,e}) = max(15,15,15) = 15
{a,e} = max({a,d,e},{a,b,e},{a,c,e}) = max(4,7,15) = 15
{b,c} = max({a,b,c},{b,c,d},{b,c,e}) = max(15,15,15) = 15
{c,d} = max({a,c,d},{b,c,d},{c,d,e}) = max(6,15,15) = 15
{c,e} = max({a,c,e},{b,c,e},{c,d,e}) = max(15,15,15) = 15
{d,e} = max({a,d,e},{b,d,e},{c,d,e}) = max(15,15,15) = 15

k=1:
{b} = 10 // already know this
{d} = 13 // already know this
{a} = max({a,d},{a,b},{a,c}{a,e}) = max(11,15,15,15) = 15
{c} = max({a,c},{b,c},{c,d},{c,e}) = max(15,15,15,15) = 15
{e} = max({b,e},{a,e},{c,e},{d,e}) = max({b,e},{a,e},{c,e},{d,e}) = max(8,15,15,15) = 15

# 2 - FP-Growth Algorithm

